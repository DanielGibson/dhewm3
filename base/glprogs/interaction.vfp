# Interaction Vertex Program
#
# Vertex Attributes
# 	8		texcoord
#	9		vertex normal(?)
#	10		vertex tangent(?)
#	11		vertex bintangent(?)
#
# Environment Values
#	4		local light position
#	5		local view position
#	6-8		light projection UVW
#	9		light falloff U
#	10-11	normal map UV
#	12-13	diffuse map UV
#	14-15	specular map UV
#	16		vertex colour modulate
#	17		vertex colour add

!!ARBvp1.0

OPTION	ARB_position_invariant;

TEMP	R0, R1;

PARAM	clearTC = { 0.0, 0.5, 0.0, 1.0 };

SUB		R0.xyz, program.env[4], vertex.position;

# tc0 : light vector in texture space
DP3		result.texcoord[0].x, R0, vertex.attrib[9];
DP3		result.texcoord[0].y, R0, vertex.attrib[10];
DP3		result.texcoord[0].z, R0, vertex.attrib[11];

# tc1 : normal map UV
DP4		result.texcoord[1].x, vertex.attrib[8], program.env[10];
DP4		result.texcoord[1].y, vertex.attrib[8], program.env[11];

# tc2 : light falloff
DP4		result.texcoord[2].x, vertex.position, program.env[9];
MOV		result.texcoord[2].yzw, clearTC;

# tc3 : light projection
DP4		result.texcoord[3].x, vertex.position, program.env[6];
DP4		result.texcoord[3].y, vertex.position, program.env[7];
DP4		result.texcoord[3].w, vertex.position, program.env[8];

# tc4 : diffuse map UV
DP4		result.texcoord[4].x, vertex.attrib[8], program.env[12];
DP4		result.texcoord[4].y, vertex.attrib[8], program.env[13];

# tc5 : specular map UV
DP4		result.texcoord[5].x, vertex.attrib[8], program.env[14];
DP4		result.texcoord[5].y, vertex.attrib[8], program.env[15];

SUB		R1.xyz, program.env[5], vertex.position;

# tc6 : view vector in texture space
DP3		result.texcoord[6].x, R1, vertex.attrib[9];
DP3		result.texcoord[6].y, R1, vertex.attrib[10];
DP3		result.texcoord[6].z, R1, vertex.attrib[11];

# no support for material stage in the engine yet
# tc7 : gloss map UV
#DP4		result.texcoord[7].x, vertex.attrib[8], program.env[14];
#DP4		result.texcoord[7].y, vertex.attrib[8], program.env[15];

# calculate vertex color ( output = vertexColor * env[16] + env[17] )
#
#				env[16]		env[17]
# 1.0			0			1
# color			1			0
# 1.0 - color	-1			1

MAD		result.color, vertex.color, program.env[16], program.env[17];

END

# Interaction Fragment Program
#
# Textures
#	0	normalization cube map ( not used in this version )
#	1	normal map
#	2	light falloff texture
#	3	light projection texture
#	4	diffuse map
#	5	specular map
#	6	specular lookup table
#	7	gloss map (material stage support in the engine is not present, yet)
#
# Environment Values
#	0	diffuse modifier
#	1	specular modifier

!!ARBfp1.0

OPTION	ARB_precision_hint_fastest;

PARAM	aVec	= { 1.0, 0.0, 0.0, 1.0 };

# parms0 : specular power
PARAM	parms0	= { 24.0, 0.0, 0.0, 0.0 };

# gloss values ( default, high gloss, low gloss )
PARAM gVals = { 16, 150, 2, 0 };

# "half-lambert" scale and bias ( set bias to something like 1 if you dont want this )
PARAM halfLamb = { 0.4, 0.6, 0, 0 };

# lighting bias ( more of the model gets lit than normally ), shadow sharpen scale, shadow sharpen bias
PARAM p0 = { 0.1, 8, -1.5, 0 };

TEMP	toView, toLight, halfVec, zeDots, lightProj, R0, R1, diffColor, specColor, outColor, localNormal;

# normalize view vector
DP3		toView.w, fragment.texcoord[6], fragment.texcoord[6];
RSQ		toView.w, toView.w;
MUL		toView.xyz, toView.w, fragment.texcoord[6];

# normalize light vector
DP3		toLight.w, fragment.texcoord[0], fragment.texcoord[0];
RSQ		toLight.w, toLight.w;
MUL		toLight.xyz, toLight.w, fragment.texcoord[0];

# construct half vector
ADD		halfVec.xyz, toView, toLight;
DP3		halfVec.w, halfVec, halfVec;
RSQ		halfVec.w, halfVec.w;
MUL		halfVec.xyz, halfVec.w, halfVec;

# look up normal ( rxgb swizzle )
TEX		localNormal, fragment.texcoord[1], texture[1], 2D;
MAD		localNormal.xyz, localNormal.wyzw, 2.0, -1.0;

DP3		R0.x, localNormal, localNormal;
RSQ		R0.x, R0.x;
MUL		localNormal.xyz, R0.x, localNormal;

# load light projection and falloff
TXP		lightProj.xyz, fragment.texcoord[3], texture[3], 2D;
TXP		R0.xyz, fragment.texcoord[2], texture[2], 2D;
MUL		lightProj.xyz, lightProj, R0;

# load diffuse map
TEX		diffColor.xyz, fragment.texcoord[4], texture[4], 2D;
MUL		diffColor.xyz, diffColor, program.env[0];

# calculate dotproducts for diffuse/specular
DP3		zeDots.x, toLight, localNormal;
DP3_SAT	zeDots.y, halfVec, localNormal;

# apply specular power
POW		R0.x, zeDots.y, parms0.x;
MUL		R0.x, R0, program.env[1];

# default Doom3 doubles the specularity
ADD		R0.x, R0, R0;

# look up specular map
TEX		specColor, fragment.texcoord[5], texture[5], 2D;

# assemble lighting
MAD		outColor.xyz, specColor, R0.x, diffColor;

# TOON (unoptimized wip)
#DP3		zeDots.w, toView, localNormal;
#DP3		zeDots.x, toLight, localNormal;
#DP3		zeDots.x, toLight, {0,0,1};
MAD_SAT	zeDots.z, zeDots.x, halfLamb.x, halfLamb.y;
# slightly increase diffuse response
ADD_SAT	zeDots.x, zeDots, p0.x;

# shadow sharpening
MAD_SAT	zeDots.x, zeDots, p0.y, p0.z;
#

# mix in half-lambert ?
MUL zeDots.x, zeDots.x, zeDots.z;

# gloss mapping in specular texture alpha ( must be below ~250 to be used, otherwise default gloss value is used )
# subtract 0.98, if value is above 0, consider it as not being glossmapped ( because texture with no alpha has alpha of 1 by default )

TEMP gloss;
SUB gloss.w, specColor.w, 0.98;
# lerp between 2 - 150 gloss power
LRP gloss.x, specColor.w, gVals.y, gVals.z;
CMP gloss.x, gloss.w, gloss, gVals;
#CMP gloss.x, gloss.w, gVals, gloss;
#


# specular shading
#MAD		R0.x, R0, 0.5, 0.2;
#FLR		R0.x, R0.x;
#MUL		R0.x, R0.x, 2;
#MUL		R0.x, R0.x, 0.75;
#
#MAD_SAT		R0.x, zeDots.y, gloss.x, gloss.y;

POW_SAT R0.x, zeDots.y, gloss.x;

#MAD_SAT		R0.x, zeDots.y, 8.0, -7;
##MAD_SAT		R0.y, zeDots.y, 64.0, -63;
#MAD_SAT		R0.y, zeDots.y
#ADD R0.x, R0.x, R0.y;
MUL R0.x, R0, 2;
MUL R0.x, R0, program.env[1];
#

#MUL		zeDots.x, zeDots.x, zeDots.z;
MUL		R0.x, R0, zeDots.x;
LRP		zeDots.x, zeDots.x, 1.0, 0.25;

TEX		R1.y, aVec, texture[0], CUBE;
SUB		R1.y, R1, 0.2;
#DP3		zeDots.w, toView, localNormal;
#MAD_SAT	zeDots.w, zeDots.w, 0.4, 0.6;
CMP		zeDots.x, R1.y, 1.0, zeDots.x;

MOV		outColor, diffColor;
MAD		outColor, specColor, R0.x, diffColor;
#MAD_SAT	zeDots.w, zeDots, 90, -6;
#MUL		outColor, zeDots.w, outColor;
#

MUL		outColor.xyz, outColor, zeDots.x;
MUL		outColor.xyz, outColor, lightProj;

#MOV outColor.xyz, gloss.x;

# apply vertex color
MUL		result.color.xyz, outColor, fragment.color;

END